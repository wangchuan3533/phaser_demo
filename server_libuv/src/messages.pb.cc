// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: messages.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "messages.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace {

const ::google::protobuf::Descriptor* Entity_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Entity_reflection_ = NULL;
const ::google::protobuf::Descriptor* JoinRoomReq_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  JoinRoomReq_reflection_ = NULL;
const ::google::protobuf::Descriptor* JoinRoomRes_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  JoinRoomRes_reflection_ = NULL;
const ::google::protobuf::Descriptor* LeaveRoomReq_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  LeaveRoomReq_reflection_ = NULL;
const ::google::protobuf::Descriptor* LeaveRoomRes_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  LeaveRoomRes_reflection_ = NULL;
const ::google::protobuf::Descriptor* CheckpointReq_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CheckpointReq_reflection_ = NULL;
const ::google::protobuf::Descriptor* CheckpointRes_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CheckpointRes_reflection_ = NULL;
const ::google::protobuf::Descriptor* UpdateNtf_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  UpdateNtf_reflection_ = NULL;
const ::google::protobuf::Descriptor* Message_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Message_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* MessageType_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_messages_2eproto() {
  protobuf_AddDesc_messages_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "messages.proto");
  GOOGLE_CHECK(file != NULL);
  Entity_descriptor_ = file->message_type(0);
  static const int Entity_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, src_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, dst_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, offset_),
  };
  Entity_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Entity_descriptor_,
      Entity::default_instance_,
      Entity_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Entity));
  JoinRoomReq_descriptor_ = file->message_type(1);
  static const int JoinRoomReq_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(JoinRoomReq, room_id_),
  };
  JoinRoomReq_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      JoinRoomReq_descriptor_,
      JoinRoomReq::default_instance_,
      JoinRoomReq_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(JoinRoomReq, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(JoinRoomReq, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(JoinRoomReq));
  JoinRoomRes_descriptor_ = file->message_type(2);
  static const int JoinRoomRes_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(JoinRoomRes, room_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(JoinRoomRes, player_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(JoinRoomRes, entities_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(JoinRoomRes, elapsed_),
  };
  JoinRoomRes_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      JoinRoomRes_descriptor_,
      JoinRoomRes::default_instance_,
      JoinRoomRes_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(JoinRoomRes, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(JoinRoomRes, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(JoinRoomRes));
  LeaveRoomReq_descriptor_ = file->message_type(3);
  static const int LeaveRoomReq_offsets_[1] = {
  };
  LeaveRoomReq_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      LeaveRoomReq_descriptor_,
      LeaveRoomReq::default_instance_,
      LeaveRoomReq_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LeaveRoomReq, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LeaveRoomReq, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(LeaveRoomReq));
  LeaveRoomRes_descriptor_ = file->message_type(4);
  static const int LeaveRoomRes_offsets_[1] = {
  };
  LeaveRoomRes_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      LeaveRoomRes_descriptor_,
      LeaveRoomRes::default_instance_,
      LeaveRoomRes_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LeaveRoomRes, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LeaveRoomRes, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(LeaveRoomRes));
  CheckpointReq_descriptor_ = file->message_type(5);
  static const int CheckpointReq_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CheckpointReq, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CheckpointReq, src_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CheckpointReq, dst_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CheckpointReq, offset_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CheckpointReq, elapsed_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CheckpointReq, latency_),
  };
  CheckpointReq_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      CheckpointReq_descriptor_,
      CheckpointReq::default_instance_,
      CheckpointReq_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CheckpointReq, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CheckpointReq, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(CheckpointReq));
  CheckpointRes_descriptor_ = file->message_type(6);
  static const int CheckpointRes_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CheckpointRes, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CheckpointRes, ret_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CheckpointRes, elapsed_),
  };
  CheckpointRes_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      CheckpointRes_descriptor_,
      CheckpointRes::default_instance_,
      CheckpointRes_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CheckpointRes, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CheckpointRes, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(CheckpointRes));
  UpdateNtf_descriptor_ = file->message_type(7);
  static const int UpdateNtf_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UpdateNtf, entities_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UpdateNtf, elapsed_),
  };
  UpdateNtf_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      UpdateNtf_descriptor_,
      UpdateNtf::default_instance_,
      UpdateNtf_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UpdateNtf, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UpdateNtf, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(UpdateNtf));
  Message_descriptor_ = file->message_type(8);
  static const int Message_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Message, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Message, data_),
  };
  Message_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Message_descriptor_,
      Message::default_instance_,
      Message_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Message, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Message, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Message));
  MessageType_descriptor_ = file->enum_type(0);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_messages_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Entity_descriptor_, &Entity::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    JoinRoomReq_descriptor_, &JoinRoomReq::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    JoinRoomRes_descriptor_, &JoinRoomRes::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    LeaveRoomReq_descriptor_, &LeaveRoomReq::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    LeaveRoomRes_descriptor_, &LeaveRoomRes::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    CheckpointReq_descriptor_, &CheckpointReq::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    CheckpointRes_descriptor_, &CheckpointRes::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    UpdateNtf_descriptor_, &UpdateNtf::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Message_descriptor_, &Message::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_messages_2eproto() {
  delete Entity::default_instance_;
  delete Entity_reflection_;
  delete JoinRoomReq::default_instance_;
  delete JoinRoomReq_reflection_;
  delete JoinRoomRes::default_instance_;
  delete JoinRoomRes_reflection_;
  delete LeaveRoomReq::default_instance_;
  delete LeaveRoomReq_reflection_;
  delete LeaveRoomRes::default_instance_;
  delete LeaveRoomRes_reflection_;
  delete CheckpointReq::default_instance_;
  delete CheckpointReq_reflection_;
  delete CheckpointRes::default_instance_;
  delete CheckpointRes_reflection_;
  delete UpdateNtf::default_instance_;
  delete UpdateNtf_reflection_;
  delete Message::default_instance_;
  delete Message_reflection_;
}

void protobuf_AddDesc_messages_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\016messages.proto\">\n\006Entity\022\n\n\002id\030\001 \002(\r\022\013"
    "\n\003src\030\002 \002(\005\022\013\n\003dst\030\003 \002(\005\022\016\n\006offset\030\004 \002(\r"
    "\"\036\n\013JoinRoomReq\022\017\n\007room_id\030\001 \002(\r\"]\n\013Join"
    "RoomRes\022\017\n\007room_id\030\001 \002(\r\022\021\n\tplayer_id\030\002 "
    "\002(\r\022\031\n\010entities\030\003 \003(\0132\007.Entity\022\017\n\007elapse"
    "d\030\004 \002(\r\"\016\n\014LeaveRoomReq\"\016\n\014LeaveRoomRes\""
    "g\n\rCheckpointReq\022\n\n\002id\030\001 \002(\r\022\013\n\003src\030\002 \002("
    "\005\022\013\n\003dst\030\003 \002(\005\022\016\n\006offset\030\004 \002(\r\022\017\n\007elapse"
    "d\030\005 \002(\r\022\017\n\007latency\030\006 \002(\r\"9\n\rCheckpointRe"
    "s\022\n\n\002id\030\001 \002(\r\022\013\n\003ret\030\002 \002(\r\022\017\n\007elapsed\030\003 "
    "\002(\r\"7\n\tUpdateNtf\022\031\n\010entities\030\001 \003(\0132\007.Ent"
    "ity\022\017\n\007elapsed\030\002 \002(\r\"3\n\007Message\022\032\n\004type\030"
    "\001 \002(\0162\014.MessageType\022\014\n\004data\030\002 \002(\014*\223\001\n\013Me"
    "ssageType\022\021\n\rJOIN_ROOM_REQ\020\001\022\021\n\rJOIN_ROO"
    "M_RES\020\002\022\022\n\016LEAVE_ROOM_REQ\020\003\022\022\n\016LEAVE_ROO"
    "M_RES\020\004\022\022\n\016CHECKPOINT_REQ\020\005\022\022\n\016CHECKPOIN"
    "T_RES\020\006\022\016\n\nUPDATE_NTF\020d", 663);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "messages.proto", &protobuf_RegisterTypes);
  Entity::default_instance_ = new Entity();
  JoinRoomReq::default_instance_ = new JoinRoomReq();
  JoinRoomRes::default_instance_ = new JoinRoomRes();
  LeaveRoomReq::default_instance_ = new LeaveRoomReq();
  LeaveRoomRes::default_instance_ = new LeaveRoomRes();
  CheckpointReq::default_instance_ = new CheckpointReq();
  CheckpointRes::default_instance_ = new CheckpointRes();
  UpdateNtf::default_instance_ = new UpdateNtf();
  Message::default_instance_ = new Message();
  Entity::default_instance_->InitAsDefaultInstance();
  JoinRoomReq::default_instance_->InitAsDefaultInstance();
  JoinRoomRes::default_instance_->InitAsDefaultInstance();
  LeaveRoomReq::default_instance_->InitAsDefaultInstance();
  LeaveRoomRes::default_instance_->InitAsDefaultInstance();
  CheckpointReq::default_instance_->InitAsDefaultInstance();
  CheckpointRes::default_instance_->InitAsDefaultInstance();
  UpdateNtf::default_instance_->InitAsDefaultInstance();
  Message::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_messages_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_messages_2eproto {
  StaticDescriptorInitializer_messages_2eproto() {
    protobuf_AddDesc_messages_2eproto();
  }
} static_descriptor_initializer_messages_2eproto_;
const ::google::protobuf::EnumDescriptor* MessageType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MessageType_descriptor_;
}
bool MessageType_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 100:
      return true;
    default:
      return false;
  }
}


// ===================================================================

#ifndef _MSC_VER
const int Entity::kIdFieldNumber;
const int Entity::kSrcFieldNumber;
const int Entity::kDstFieldNumber;
const int Entity::kOffsetFieldNumber;
#endif  // !_MSC_VER

Entity::Entity()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Entity)
}

void Entity::InitAsDefaultInstance() {
}

Entity::Entity(const Entity& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Entity)
}

void Entity::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0u;
  src_ = 0;
  dst_ = 0;
  offset_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Entity::~Entity() {
  // @@protoc_insertion_point(destructor:Entity)
  SharedDtor();
}

void Entity::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Entity::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Entity::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Entity_descriptor_;
}

const Entity& Entity::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

Entity* Entity::default_instance_ = NULL;

Entity* Entity::New() const {
  return new Entity;
}

void Entity::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<Entity*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(id_, offset_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Entity::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Entity)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_src;
        break;
      }

      // required int32 src = 2;
      case 2: {
        if (tag == 16) {
         parse_src:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &src_)));
          set_has_src();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_dst;
        break;
      }

      // required int32 dst = 3;
      case 3: {
        if (tag == 24) {
         parse_dst:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &dst_)));
          set_has_dst();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_offset;
        break;
      }

      // required uint32 offset = 4;
      case 4: {
        if (tag == 32) {
         parse_offset:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &offset_)));
          set_has_offset();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Entity)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Entity)
  return false;
#undef DO_
}

void Entity::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Entity)
  // required uint32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->id(), output);
  }

  // required int32 src = 2;
  if (has_src()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->src(), output);
  }

  // required int32 dst = 3;
  if (has_dst()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->dst(), output);
  }

  // required uint32 offset = 4;
  if (has_offset()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->offset(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Entity)
}

::google::protobuf::uint8* Entity::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:Entity)
  // required uint32 id = 1;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->id(), target);
  }

  // required int32 src = 2;
  if (has_src()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->src(), target);
  }

  // required int32 dst = 3;
  if (has_dst()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->dst(), target);
  }

  // required uint32 offset = 4;
  if (has_offset()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->offset(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Entity)
  return target;
}

int Entity::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->id());
    }

    // required int32 src = 2;
    if (has_src()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->src());
    }

    // required int32 dst = 3;
    if (has_dst()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->dst());
    }

    // required uint32 offset = 4;
    if (has_offset()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->offset());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Entity::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Entity* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Entity*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Entity::MergeFrom(const Entity& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_src()) {
      set_src(from.src());
    }
    if (from.has_dst()) {
      set_dst(from.dst());
    }
    if (from.has_offset()) {
      set_offset(from.offset());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Entity::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Entity::CopyFrom(const Entity& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Entity::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  return true;
}

void Entity::Swap(Entity* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(src_, other->src_);
    std::swap(dst_, other->dst_);
    std::swap(offset_, other->offset_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Entity::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Entity_descriptor_;
  metadata.reflection = Entity_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int JoinRoomReq::kRoomIdFieldNumber;
#endif  // !_MSC_VER

JoinRoomReq::JoinRoomReq()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:JoinRoomReq)
}

void JoinRoomReq::InitAsDefaultInstance() {
}

JoinRoomReq::JoinRoomReq(const JoinRoomReq& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:JoinRoomReq)
}

void JoinRoomReq::SharedCtor() {
  _cached_size_ = 0;
  room_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

JoinRoomReq::~JoinRoomReq() {
  // @@protoc_insertion_point(destructor:JoinRoomReq)
  SharedDtor();
}

void JoinRoomReq::SharedDtor() {
  if (this != default_instance_) {
  }
}

void JoinRoomReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* JoinRoomReq::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return JoinRoomReq_descriptor_;
}

const JoinRoomReq& JoinRoomReq::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

JoinRoomReq* JoinRoomReq::default_instance_ = NULL;

JoinRoomReq* JoinRoomReq::New() const {
  return new JoinRoomReq;
}

void JoinRoomReq::Clear() {
  room_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool JoinRoomReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:JoinRoomReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 room_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &room_id_)));
          set_has_room_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:JoinRoomReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:JoinRoomReq)
  return false;
#undef DO_
}

void JoinRoomReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:JoinRoomReq)
  // required uint32 room_id = 1;
  if (has_room_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->room_id(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:JoinRoomReq)
}

::google::protobuf::uint8* JoinRoomReq::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:JoinRoomReq)
  // required uint32 room_id = 1;
  if (has_room_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->room_id(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:JoinRoomReq)
  return target;
}

int JoinRoomReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 room_id = 1;
    if (has_room_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->room_id());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void JoinRoomReq::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const JoinRoomReq* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const JoinRoomReq*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void JoinRoomReq::MergeFrom(const JoinRoomReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_room_id()) {
      set_room_id(from.room_id());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void JoinRoomReq::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void JoinRoomReq::CopyFrom(const JoinRoomReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool JoinRoomReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void JoinRoomReq::Swap(JoinRoomReq* other) {
  if (other != this) {
    std::swap(room_id_, other->room_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata JoinRoomReq::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = JoinRoomReq_descriptor_;
  metadata.reflection = JoinRoomReq_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int JoinRoomRes::kRoomIdFieldNumber;
const int JoinRoomRes::kPlayerIdFieldNumber;
const int JoinRoomRes::kEntitiesFieldNumber;
const int JoinRoomRes::kElapsedFieldNumber;
#endif  // !_MSC_VER

JoinRoomRes::JoinRoomRes()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:JoinRoomRes)
}

void JoinRoomRes::InitAsDefaultInstance() {
}

JoinRoomRes::JoinRoomRes(const JoinRoomRes& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:JoinRoomRes)
}

void JoinRoomRes::SharedCtor() {
  _cached_size_ = 0;
  room_id_ = 0u;
  player_id_ = 0u;
  elapsed_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

JoinRoomRes::~JoinRoomRes() {
  // @@protoc_insertion_point(destructor:JoinRoomRes)
  SharedDtor();
}

void JoinRoomRes::SharedDtor() {
  if (this != default_instance_) {
  }
}

void JoinRoomRes::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* JoinRoomRes::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return JoinRoomRes_descriptor_;
}

const JoinRoomRes& JoinRoomRes::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

JoinRoomRes* JoinRoomRes::default_instance_ = NULL;

JoinRoomRes* JoinRoomRes::New() const {
  return new JoinRoomRes;
}

void JoinRoomRes::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<JoinRoomRes*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 11) {
    ZR_(room_id_, player_id_);
    elapsed_ = 0u;
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  entities_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool JoinRoomRes::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:JoinRoomRes)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 room_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &room_id_)));
          set_has_room_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_player_id;
        break;
      }

      // required uint32 player_id = 2;
      case 2: {
        if (tag == 16) {
         parse_player_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &player_id_)));
          set_has_player_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_entities;
        break;
      }

      // repeated .Entity entities = 3;
      case 3: {
        if (tag == 26) {
         parse_entities:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_entities()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_entities;
        if (input->ExpectTag(32)) goto parse_elapsed;
        break;
      }

      // required uint32 elapsed = 4;
      case 4: {
        if (tag == 32) {
         parse_elapsed:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &elapsed_)));
          set_has_elapsed();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:JoinRoomRes)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:JoinRoomRes)
  return false;
#undef DO_
}

void JoinRoomRes::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:JoinRoomRes)
  // required uint32 room_id = 1;
  if (has_room_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->room_id(), output);
  }

  // required uint32 player_id = 2;
  if (has_player_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->player_id(), output);
  }

  // repeated .Entity entities = 3;
  for (int i = 0; i < this->entities_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->entities(i), output);
  }

  // required uint32 elapsed = 4;
  if (has_elapsed()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->elapsed(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:JoinRoomRes)
}

::google::protobuf::uint8* JoinRoomRes::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:JoinRoomRes)
  // required uint32 room_id = 1;
  if (has_room_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->room_id(), target);
  }

  // required uint32 player_id = 2;
  if (has_player_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->player_id(), target);
  }

  // repeated .Entity entities = 3;
  for (int i = 0; i < this->entities_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->entities(i), target);
  }

  // required uint32 elapsed = 4;
  if (has_elapsed()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->elapsed(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:JoinRoomRes)
  return target;
}

int JoinRoomRes::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 room_id = 1;
    if (has_room_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->room_id());
    }

    // required uint32 player_id = 2;
    if (has_player_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->player_id());
    }

    // required uint32 elapsed = 4;
    if (has_elapsed()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->elapsed());
    }

  }
  // repeated .Entity entities = 3;
  total_size += 1 * this->entities_size();
  for (int i = 0; i < this->entities_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->entities(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void JoinRoomRes::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const JoinRoomRes* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const JoinRoomRes*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void JoinRoomRes::MergeFrom(const JoinRoomRes& from) {
  GOOGLE_CHECK_NE(&from, this);
  entities_.MergeFrom(from.entities_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_room_id()) {
      set_room_id(from.room_id());
    }
    if (from.has_player_id()) {
      set_player_id(from.player_id());
    }
    if (from.has_elapsed()) {
      set_elapsed(from.elapsed());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void JoinRoomRes::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void JoinRoomRes::CopyFrom(const JoinRoomRes& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool JoinRoomRes::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000b) != 0x0000000b) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->entities())) return false;
  return true;
}

void JoinRoomRes::Swap(JoinRoomRes* other) {
  if (other != this) {
    std::swap(room_id_, other->room_id_);
    std::swap(player_id_, other->player_id_);
    entities_.Swap(&other->entities_);
    std::swap(elapsed_, other->elapsed_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata JoinRoomRes::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = JoinRoomRes_descriptor_;
  metadata.reflection = JoinRoomRes_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

LeaveRoomReq::LeaveRoomReq()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:LeaveRoomReq)
}

void LeaveRoomReq::InitAsDefaultInstance() {
}

LeaveRoomReq::LeaveRoomReq(const LeaveRoomReq& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:LeaveRoomReq)
}

void LeaveRoomReq::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LeaveRoomReq::~LeaveRoomReq() {
  // @@protoc_insertion_point(destructor:LeaveRoomReq)
  SharedDtor();
}

void LeaveRoomReq::SharedDtor() {
  if (this != default_instance_) {
  }
}

void LeaveRoomReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* LeaveRoomReq::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return LeaveRoomReq_descriptor_;
}

const LeaveRoomReq& LeaveRoomReq::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

LeaveRoomReq* LeaveRoomReq::default_instance_ = NULL;

LeaveRoomReq* LeaveRoomReq::New() const {
  return new LeaveRoomReq;
}

void LeaveRoomReq::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool LeaveRoomReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:LeaveRoomReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, mutable_unknown_fields()));
  }
success:
  // @@protoc_insertion_point(parse_success:LeaveRoomReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:LeaveRoomReq)
  return false;
#undef DO_
}

void LeaveRoomReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:LeaveRoomReq)
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:LeaveRoomReq)
}

::google::protobuf::uint8* LeaveRoomReq::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:LeaveRoomReq)
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:LeaveRoomReq)
  return target;
}

int LeaveRoomReq::ByteSize() const {
  int total_size = 0;

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LeaveRoomReq::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const LeaveRoomReq* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const LeaveRoomReq*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void LeaveRoomReq::MergeFrom(const LeaveRoomReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void LeaveRoomReq::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LeaveRoomReq::CopyFrom(const LeaveRoomReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LeaveRoomReq::IsInitialized() const {

  return true;
}

void LeaveRoomReq::Swap(LeaveRoomReq* other) {
  if (other != this) {
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata LeaveRoomReq::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = LeaveRoomReq_descriptor_;
  metadata.reflection = LeaveRoomReq_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

LeaveRoomRes::LeaveRoomRes()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:LeaveRoomRes)
}

void LeaveRoomRes::InitAsDefaultInstance() {
}

LeaveRoomRes::LeaveRoomRes(const LeaveRoomRes& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:LeaveRoomRes)
}

void LeaveRoomRes::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LeaveRoomRes::~LeaveRoomRes() {
  // @@protoc_insertion_point(destructor:LeaveRoomRes)
  SharedDtor();
}

void LeaveRoomRes::SharedDtor() {
  if (this != default_instance_) {
  }
}

void LeaveRoomRes::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* LeaveRoomRes::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return LeaveRoomRes_descriptor_;
}

const LeaveRoomRes& LeaveRoomRes::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

LeaveRoomRes* LeaveRoomRes::default_instance_ = NULL;

LeaveRoomRes* LeaveRoomRes::New() const {
  return new LeaveRoomRes;
}

void LeaveRoomRes::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool LeaveRoomRes::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:LeaveRoomRes)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, mutable_unknown_fields()));
  }
success:
  // @@protoc_insertion_point(parse_success:LeaveRoomRes)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:LeaveRoomRes)
  return false;
#undef DO_
}

void LeaveRoomRes::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:LeaveRoomRes)
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:LeaveRoomRes)
}

::google::protobuf::uint8* LeaveRoomRes::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:LeaveRoomRes)
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:LeaveRoomRes)
  return target;
}

int LeaveRoomRes::ByteSize() const {
  int total_size = 0;

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LeaveRoomRes::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const LeaveRoomRes* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const LeaveRoomRes*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void LeaveRoomRes::MergeFrom(const LeaveRoomRes& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void LeaveRoomRes::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LeaveRoomRes::CopyFrom(const LeaveRoomRes& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LeaveRoomRes::IsInitialized() const {

  return true;
}

void LeaveRoomRes::Swap(LeaveRoomRes* other) {
  if (other != this) {
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata LeaveRoomRes::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = LeaveRoomRes_descriptor_;
  metadata.reflection = LeaveRoomRes_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int CheckpointReq::kIdFieldNumber;
const int CheckpointReq::kSrcFieldNumber;
const int CheckpointReq::kDstFieldNumber;
const int CheckpointReq::kOffsetFieldNumber;
const int CheckpointReq::kElapsedFieldNumber;
const int CheckpointReq::kLatencyFieldNumber;
#endif  // !_MSC_VER

CheckpointReq::CheckpointReq()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:CheckpointReq)
}

void CheckpointReq::InitAsDefaultInstance() {
}

CheckpointReq::CheckpointReq(const CheckpointReq& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CheckpointReq)
}

void CheckpointReq::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0u;
  src_ = 0;
  dst_ = 0;
  offset_ = 0u;
  elapsed_ = 0u;
  latency_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CheckpointReq::~CheckpointReq() {
  // @@protoc_insertion_point(destructor:CheckpointReq)
  SharedDtor();
}

void CheckpointReq::SharedDtor() {
  if (this != default_instance_) {
  }
}

void CheckpointReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CheckpointReq::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CheckpointReq_descriptor_;
}

const CheckpointReq& CheckpointReq::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

CheckpointReq* CheckpointReq::default_instance_ = NULL;

CheckpointReq* CheckpointReq::New() const {
  return new CheckpointReq;
}

void CheckpointReq::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CheckpointReq*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 63) {
    ZR_(id_, latency_);
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool CheckpointReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CheckpointReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_src;
        break;
      }

      // required int32 src = 2;
      case 2: {
        if (tag == 16) {
         parse_src:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &src_)));
          set_has_src();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_dst;
        break;
      }

      // required int32 dst = 3;
      case 3: {
        if (tag == 24) {
         parse_dst:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &dst_)));
          set_has_dst();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_offset;
        break;
      }

      // required uint32 offset = 4;
      case 4: {
        if (tag == 32) {
         parse_offset:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &offset_)));
          set_has_offset();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_elapsed;
        break;
      }

      // required uint32 elapsed = 5;
      case 5: {
        if (tag == 40) {
         parse_elapsed:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &elapsed_)));
          set_has_elapsed();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_latency;
        break;
      }

      // required uint32 latency = 6;
      case 6: {
        if (tag == 48) {
         parse_latency:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &latency_)));
          set_has_latency();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CheckpointReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CheckpointReq)
  return false;
#undef DO_
}

void CheckpointReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CheckpointReq)
  // required uint32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->id(), output);
  }

  // required int32 src = 2;
  if (has_src()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->src(), output);
  }

  // required int32 dst = 3;
  if (has_dst()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->dst(), output);
  }

  // required uint32 offset = 4;
  if (has_offset()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->offset(), output);
  }

  // required uint32 elapsed = 5;
  if (has_elapsed()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->elapsed(), output);
  }

  // required uint32 latency = 6;
  if (has_latency()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->latency(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:CheckpointReq)
}

::google::protobuf::uint8* CheckpointReq::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:CheckpointReq)
  // required uint32 id = 1;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->id(), target);
  }

  // required int32 src = 2;
  if (has_src()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->src(), target);
  }

  // required int32 dst = 3;
  if (has_dst()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->dst(), target);
  }

  // required uint32 offset = 4;
  if (has_offset()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->offset(), target);
  }

  // required uint32 elapsed = 5;
  if (has_elapsed()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->elapsed(), target);
  }

  // required uint32 latency = 6;
  if (has_latency()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(6, this->latency(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CheckpointReq)
  return target;
}

int CheckpointReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->id());
    }

    // required int32 src = 2;
    if (has_src()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->src());
    }

    // required int32 dst = 3;
    if (has_dst()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->dst());
    }

    // required uint32 offset = 4;
    if (has_offset()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->offset());
    }

    // required uint32 elapsed = 5;
    if (has_elapsed()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->elapsed());
    }

    // required uint32 latency = 6;
    if (has_latency()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->latency());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CheckpointReq::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const CheckpointReq* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const CheckpointReq*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CheckpointReq::MergeFrom(const CheckpointReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_src()) {
      set_src(from.src());
    }
    if (from.has_dst()) {
      set_dst(from.dst());
    }
    if (from.has_offset()) {
      set_offset(from.offset());
    }
    if (from.has_elapsed()) {
      set_elapsed(from.elapsed());
    }
    if (from.has_latency()) {
      set_latency(from.latency());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void CheckpointReq::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CheckpointReq::CopyFrom(const CheckpointReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CheckpointReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000003f) != 0x0000003f) return false;

  return true;
}

void CheckpointReq::Swap(CheckpointReq* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(src_, other->src_);
    std::swap(dst_, other->dst_);
    std::swap(offset_, other->offset_);
    std::swap(elapsed_, other->elapsed_);
    std::swap(latency_, other->latency_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata CheckpointReq::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CheckpointReq_descriptor_;
  metadata.reflection = CheckpointReq_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int CheckpointRes::kIdFieldNumber;
const int CheckpointRes::kRetFieldNumber;
const int CheckpointRes::kElapsedFieldNumber;
#endif  // !_MSC_VER

CheckpointRes::CheckpointRes()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:CheckpointRes)
}

void CheckpointRes::InitAsDefaultInstance() {
}

CheckpointRes::CheckpointRes(const CheckpointRes& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CheckpointRes)
}

void CheckpointRes::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0u;
  ret_ = 0u;
  elapsed_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CheckpointRes::~CheckpointRes() {
  // @@protoc_insertion_point(destructor:CheckpointRes)
  SharedDtor();
}

void CheckpointRes::SharedDtor() {
  if (this != default_instance_) {
  }
}

void CheckpointRes::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CheckpointRes::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CheckpointRes_descriptor_;
}

const CheckpointRes& CheckpointRes::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

CheckpointRes* CheckpointRes::default_instance_ = NULL;

CheckpointRes* CheckpointRes::New() const {
  return new CheckpointRes;
}

void CheckpointRes::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CheckpointRes*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(id_, elapsed_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool CheckpointRes::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:CheckpointRes)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_ret;
        break;
      }

      // required uint32 ret = 2;
      case 2: {
        if (tag == 16) {
         parse_ret:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &ret_)));
          set_has_ret();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_elapsed;
        break;
      }

      // required uint32 elapsed = 3;
      case 3: {
        if (tag == 24) {
         parse_elapsed:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &elapsed_)));
          set_has_elapsed();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CheckpointRes)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CheckpointRes)
  return false;
#undef DO_
}

void CheckpointRes::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CheckpointRes)
  // required uint32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->id(), output);
  }

  // required uint32 ret = 2;
  if (has_ret()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->ret(), output);
  }

  // required uint32 elapsed = 3;
  if (has_elapsed()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->elapsed(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:CheckpointRes)
}

::google::protobuf::uint8* CheckpointRes::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:CheckpointRes)
  // required uint32 id = 1;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->id(), target);
  }

  // required uint32 ret = 2;
  if (has_ret()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->ret(), target);
  }

  // required uint32 elapsed = 3;
  if (has_elapsed()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->elapsed(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CheckpointRes)
  return target;
}

int CheckpointRes::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->id());
    }

    // required uint32 ret = 2;
    if (has_ret()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->ret());
    }

    // required uint32 elapsed = 3;
    if (has_elapsed()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->elapsed());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CheckpointRes::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const CheckpointRes* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const CheckpointRes*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CheckpointRes::MergeFrom(const CheckpointRes& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_ret()) {
      set_ret(from.ret());
    }
    if (from.has_elapsed()) {
      set_elapsed(from.elapsed());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void CheckpointRes::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CheckpointRes::CopyFrom(const CheckpointRes& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CheckpointRes::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void CheckpointRes::Swap(CheckpointRes* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(ret_, other->ret_);
    std::swap(elapsed_, other->elapsed_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata CheckpointRes::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CheckpointRes_descriptor_;
  metadata.reflection = CheckpointRes_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int UpdateNtf::kEntitiesFieldNumber;
const int UpdateNtf::kElapsedFieldNumber;
#endif  // !_MSC_VER

UpdateNtf::UpdateNtf()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:UpdateNtf)
}

void UpdateNtf::InitAsDefaultInstance() {
}

UpdateNtf::UpdateNtf(const UpdateNtf& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:UpdateNtf)
}

void UpdateNtf::SharedCtor() {
  _cached_size_ = 0;
  elapsed_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UpdateNtf::~UpdateNtf() {
  // @@protoc_insertion_point(destructor:UpdateNtf)
  SharedDtor();
}

void UpdateNtf::SharedDtor() {
  if (this != default_instance_) {
  }
}

void UpdateNtf::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* UpdateNtf::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return UpdateNtf_descriptor_;
}

const UpdateNtf& UpdateNtf::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

UpdateNtf* UpdateNtf::default_instance_ = NULL;

UpdateNtf* UpdateNtf::New() const {
  return new UpdateNtf;
}

void UpdateNtf::Clear() {
  elapsed_ = 0u;
  entities_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool UpdateNtf::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:UpdateNtf)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .Entity entities = 1;
      case 1: {
        if (tag == 10) {
         parse_entities:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_entities()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_entities;
        if (input->ExpectTag(16)) goto parse_elapsed;
        break;
      }

      // required uint32 elapsed = 2;
      case 2: {
        if (tag == 16) {
         parse_elapsed:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &elapsed_)));
          set_has_elapsed();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:UpdateNtf)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:UpdateNtf)
  return false;
#undef DO_
}

void UpdateNtf::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:UpdateNtf)
  // repeated .Entity entities = 1;
  for (int i = 0; i < this->entities_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->entities(i), output);
  }

  // required uint32 elapsed = 2;
  if (has_elapsed()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->elapsed(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:UpdateNtf)
}

::google::protobuf::uint8* UpdateNtf::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:UpdateNtf)
  // repeated .Entity entities = 1;
  for (int i = 0; i < this->entities_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->entities(i), target);
  }

  // required uint32 elapsed = 2;
  if (has_elapsed()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->elapsed(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:UpdateNtf)
  return target;
}

int UpdateNtf::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // required uint32 elapsed = 2;
    if (has_elapsed()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->elapsed());
    }

  }
  // repeated .Entity entities = 1;
  total_size += 1 * this->entities_size();
  for (int i = 0; i < this->entities_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->entities(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UpdateNtf::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const UpdateNtf* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const UpdateNtf*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void UpdateNtf::MergeFrom(const UpdateNtf& from) {
  GOOGLE_CHECK_NE(&from, this);
  entities_.MergeFrom(from.entities_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_elapsed()) {
      set_elapsed(from.elapsed());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void UpdateNtf::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UpdateNtf::CopyFrom(const UpdateNtf& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UpdateNtf::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000002) != 0x00000002) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->entities())) return false;
  return true;
}

void UpdateNtf::Swap(UpdateNtf* other) {
  if (other != this) {
    entities_.Swap(&other->entities_);
    std::swap(elapsed_, other->elapsed_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata UpdateNtf::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = UpdateNtf_descriptor_;
  metadata.reflection = UpdateNtf_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Message::kTypeFieldNumber;
const int Message::kDataFieldNumber;
#endif  // !_MSC_VER

Message::Message()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Message)
}

void Message::InitAsDefaultInstance() {
}

Message::Message(const Message& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Message)
}

void Message::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  type_ = 1;
  data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Message::~Message() {
  // @@protoc_insertion_point(destructor:Message)
  SharedDtor();
}

void Message::SharedDtor() {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete data_;
  }
  if (this != default_instance_) {
  }
}

void Message::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Message::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Message_descriptor_;
}

const Message& Message::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

Message* Message::default_instance_ = NULL;

Message* Message::New() const {
  return new Message;
}

void Message::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    type_ = 1;
    if (has_data()) {
      if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        data_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Message::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Message)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .MessageType type = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::MessageType_IsValid(value)) {
            set_type(static_cast< ::MessageType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_data;
        break;
      }

      // required bytes data = 2;
      case 2: {
        if (tag == 18) {
         parse_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Message)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Message)
  return false;
#undef DO_
}

void Message::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Message)
  // required .MessageType type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // required bytes data = 2;
  if (has_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->data(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Message)
}

::google::protobuf::uint8* Message::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:Message)
  // required .MessageType type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }

  // required bytes data = 2;
  if (has_data()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->data(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Message)
  return target;
}

int Message::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .MessageType type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // required bytes data = 2;
    if (has_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->data());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Message::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Message* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Message*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Message::MergeFrom(const Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_data()) {
      set_data(from.data());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Message::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Message::CopyFrom(const Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Message::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void Message::Swap(Message* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(data_, other->data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Message::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Message_descriptor_;
  metadata.reflection = Message_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

// @@protoc_insertion_point(global_scope)
